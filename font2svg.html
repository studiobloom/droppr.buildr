<!DOCTYPE html>
<html>
<head>
    <title>font2svg</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/0.12.0/opentype.min.js"></script>
</head>
<body>
    <h1>SVG Text Generator</h1>
    <form id="uploadForm">
        <input type="file" id="fontFile" accept=".ttf,.otf,.woff,.woff2,.eot" required>
        <br>
        <textarea id="textInput" rows="4" cols="50" required></textarea>
        <br>
        <button type="submit">Generate SVG</button>
    </form>
    <div id="svgOutput"></div>
    <a href="#" id="downloadLink" style="display: none;">Download SVG</a>

    <script>
        document.getElementById('uploadForm').addEventListener('submit', function(event) {
            event.preventDefault();
            const fontFile = document.getElementById('fontFile').files[0];
            const textInput = document.getElementById('textInput').value;

            const fileReader = new FileReader();
            fileReader.onload = async function() {
                const fontArrayBuffer = fileReader.result;
                try {
                    const font = opentype.parse(fontArrayBuffer);
                    const fontSize = 200; // Increase font size for better resolution

                    // Create an SVG element
                    const svgNS = 'http://www.w3.org/2000/svg';
                    const svgElem = document.createElementNS(svgNS, 'svg');
                    svgElem.setAttribute('xmlns', svgNS);
                    svgElem.setAttribute('width', 1000); // Set a suitable width for the SVG
                    svgElem.setAttribute('height', 200); // Set a suitable height for the SVG

                    // Create a group element to hold the paths
                    const groupElem = document.createElementNS(svgNS, 'g');

                    // Calculate the total width required for the text
                    let totalWidth = Array.from(textInput).reduce((acc, char) => {
                        const glyph = font.charToGlyph(char);
                        return acc + glyph.advanceWidth * fontSize / font.unitsPerEm;
                    }, 0);

                    let x = (1000 - totalWidth) / 2; // Center the text horizontally

                    // Create paths for each character and add them to the group
                    for (const char of textInput) {
                        const glyph = font.charToGlyph(char);
                        const path = glyph.getPath(x, 150, fontSize);

                        const pathElem = document.createElementNS(svgNS, 'path');
                        pathElem.setAttribute('d', path.toPathData());
                        groupElem.appendChild(pathElem);

                        x += glyph.advanceWidth * fontSize / font.unitsPerEm;
                    }

                    // Add the group to the SVG
                    svgElem.appendChild(groupElem);

                    // Add the SVG to your page
                    const svgOutputDiv = document.getElementById('svgOutput');
                    svgOutputDiv.innerHTML = '';
                    svgOutputDiv.appendChild(svgElem);

                    // Add a link to download the SVG
                    const downloadLink = document.getElementById('downloadLink');
                    downloadLink.href = "data:image/svg+xml," + encodeURIComponent(svgElem.outerHTML);
                    downloadLink.download = textInput.replace(/\s/g, '_') + ".svg"; // Set the filename based on the text input
                    downloadLink.style.display = "block";
                } catch (err) {
                    console.error("Could not load font:", err);
                }
            };

            fileReader.readAsArrayBuffer(fontFile);
        });
    </script>
</body>
</html>
